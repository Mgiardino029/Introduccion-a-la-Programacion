program {

}

type DiaDeLaSemana is variant {

    /*
    proposito: declara los dias de la semana
    */


    case Lunes{}
    case Martes{}
    case Miercoles{}
    case Jueves{}
    case Viernes{}
    case Sabado{}
    case Domingo{}
    



}

// 1.- A)


function diaSiguiente_(dia) {
    /*
    proposito: describe el dia siguiente al dia "dia"
    precondiciones: ninguna
    parametros: dia : DiaDeLaSemana
    Tipo: DiaDeLaSemana
    observaciones:
    */

    return(choose Lunes when (dia == Domingo)
        Martes when (dia == Lunes)
        Miercoles when (dia == Martes)
        Jueves when (dia == Miercoles)
        Viernes when (dia == Jueves)
        Sabado when (dia == Viernes)
        Domingo when (dia == Sabado))

    
}   


// 1.- B)


function diaPrevio_(dia) {
    /*
    proposito: describe el dia previo al dia "dia"
    precondicion: ninguna
    parametros: dia : DiaDeLaSemana
    tipo: DiaDeLaSemana
    observaciones:
    */


    return( choose Domingo when (dia == Lunes)
        Lunes when (dia == Martes)
        Martes when (dia == Miercoles)
        Miercoles when (dia == Jueves)
        Jueves when (dia == Viernes)
        Viernes when (dia == Sabado)
        Sabado when (dia == Domingo)            )
}



// 1.- C)



function esDiaDeFinDeSemana_(dia) {
    /*
    proposito: indica si el dia dado es un dia de fin de semana
    precondiciones: ninguna
    parametros: DiaDeLaSemana
    tipo: Bolleano
    Observacion: un dia de fin de semana es Sabado o Domingo
    */

    return( dia == Sabado || dia == Domingo)

}

/* Reflexion: el parametro dado en cada funcion es del tipo "dia", las funciones no pueden utilizarse para solucionar este problema ya q es una alternativa condicional. los beneficios
    que traen diaSiguiente y diaPrevio es que podes llamar es q sabiendo en q dia estas te retorna el dia anterior o el siguiente */




// 2.-

type PartidoPolitico is variant {
    /*
    proposito: modelar un partido politico
    */

    case DemocraciaPorLaVerdad{}
    case UnidosPorLaRepublica{}
    case LiberalesPorLaLibertad{}
    case IzquierdaDeLosObreros{}


}

function cantidadDeVotosDe_(unPartido) {
    /*
    proposito: indica la cantidad de votos que rceibio un partido
    parametros:
    unPartido: PartidoPolitico - el partido politico del cual saber su cantidad de votos
    tipo: numero
    precondicion: ninguna
    */


}

// 2.- A)

function tieneMasVotantes_Que_(primerPartidoPolitico, segundoPartidoPolitico) {
    /*
    proposito: describe quien tiene mas votos entre "primerPartidoPolitico" y "segundoPartidoPolitico"
    precondiciones: uno de los dos debe tener mas votos que el otro
    parametros:
    primerPartidoPolitico - PartidoPolitico - primer partido politico a comparar
    segundoPartidoPolitico - PartidoPolitico - segundo partido politico a comparar
    tipo: PartidoPolitico
    observaciones: 
    */

    return(choose primerPartidoPolitico when cantidadDeVotosDe_(primerPartidoPolitico) > cantidadDeVotosDe_(segundoPartidoPolitico)) 
        segundoPartidoPolitico otherwise
}



// 3.-  


// program {

    return(CartaEspañola(palo <- Basto , numero))

}


type Palo is variant {
    /*
    proposito: modelar un palo
    */

    case Basto{}
    case Espada{}
    case Copa{}
    case Oro{}
}


type CartaEspañola is record {
    /*
    proposito: modelar una carta española
    invariante de representacion: el numero esta entre 1 y 12
    */

    field palo // palo
    field numero // numero
}

// 3.- C)

function laCarta_de_(numeroDeLaCarta, paloDeLaCarta) {
    /*
    proposito: describe la carta de "numeroDeLaCarta* del palo "paloDeLaCarta"
    precondiciones: el "numeroDeLaCarta" debe estar entre 1 y 12
    tipo: CartaEspañola
    parametros: 
    numero: numero
    palo: palo
    */

    return(CartaEspañola(numero, palo))


}

// 3.- B)


function anchoDeBastos() {
    /*
    proposito: describe la carta ancho de bastos
    precondiciones: ninguna
    tipo: CartaEspañola 

    */


    return(laCarta_de_(1, Basto))

}

// 3.- D)

function esUnAncho_(carta){
    /*
    proposito: indica si la carta "carta" es un ancho
    precondiciones: ninguna
    tipo: booleano
    parametros: 
    * carta: CartaEspañola
    observaciones: el ancho son las cartas que tienen numero 1
    */

    return (numero(carta) == 1)
}

// 3.- 

function cartearAncho() {
    /*
    proposito: describe la carta "carta"a ancho de espada
    precondiciones: "carta" debe ser un ancho
    parametros: carta: cartaEspañola
    tipo: cartaEspañola
    observaciones:
    */

    return(CartaEspañola(carta | palo <- Espada))
}


type Estudiante is record {

    field legajo          // numero
    field numeroDocumento // Numero
    field tipoDeDocumento // TipoDeDocumento
    field fechaNac        // FechaNac
    field nombreCompleto  // String    


}